<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CKEditor 5 – balloon block editor build – development sample</title>
	<style>
		body {
			margin: 20px auto;
		}

		h1 {
			max-width: 870px;
			margin: 1em auto;
		}
	</style>
</head>
<body>

<h1>CKEditor 5 – balloon block editor build – development sample</h1>

<div id="editor">
	<h2>Sample</h2>

	<p>This is an instance of the <a href="https://ckeditor.com/docs/ckeditor5/latest/builds/guides/overview.html#balloon-editor">balloon block editor build</a>.</p>

	<figure class="image">
		<img src="../tests/manual/sample.jpg" alt="Autumn fields" />
	</figure>

	<p>You can use this sample to validate whether your <a href="https://ckeditor.com/docs/ckeditor5/latest/builds/guides/development/custom-builds.html">custom build</a> works fine.</p>
</div>

<script src="../build/ckeditor.js"></script>
<script>
	BalloonEditor.create( document.querySelector( '#editor' ) )
		.then( editor => {
			window.editor = editor;
			window.env = BalloonEditor.env
			editor.plugins.get( 'ImageUploadEditing' )._readAndUpload =
				function ( loader, imageElement ) {
					const editor = this.editor;
					const model = editor.model;
					const t = editor.locale.t;
					const fileRepository = editor.plugins.get( 'FileRepository' );
					const notification = editor.plugins.get( 'Notification' );

					model.enqueueChange( 'transparent', writer => {
						writer.setAttribute( 'uploadStatus', 'reading', imageElement );
					} );

					return loader.read()
						.then( () => {
							const promise = loader.upload();

							// Force re–paint in Safari. Without it, the image will display with a wrong size.
							// https://github.com/ckeditor/ckeditor5/issues/1975
							/* istanbul ignore next */
							if ( env.isSafari ) {
								const viewFigure = editor.editing.mapper.toViewElement( imageElement );
								const viewImg = viewFigure.getChild( 0 );

								editor.editing.view.once( 'render', () => {
									// Early returns just to be safe. There might be some code ran
									// in between the outer scope and this callback.
									if ( !viewImg.parent ) {
										return;
									}

									const domFigure = editor.editing.view.domConverter.mapViewToDom( viewImg.parent );

									if ( !domFigure ) {
										return;
									}

									const originalDisplay = domFigure.style.display;

									domFigure.style.display = 'none';

									// Make sure this line will never be removed during minification for having "no effect".
									domFigure._ckHack = domFigure.offsetHeight;

									domFigure.style.display = originalDisplay;
								} );
							}

							model.enqueueChange( 'transparent', writer => {
								writer.setAttribute( 'uploadStatus', 'uploading', imageElement );
							} );

							return promise;
						} )
						.then( data => {
							model.enqueueChange( 'transparent', writer => {
								console.log('in enque');
								writer.setAttributes( { uploadStatus: 'complete', src: data.default }, imageElement );
								this._parseAndSetSrcsetAttributeOnImage( data, imageElement, writer );
							} );

							clean();
						} )
						.catch( error => {
							// If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,
							// it might be generic error and it would be real pain to find what is going on.
							if ( loader.status !== 'error' && loader.status !== 'aborted' ) {
								throw error;
							}

							// Might be 'aborted'.
							if ( loader.status == 'error' && error ) {
								notification.showWarning( error, {
									title: t( 'Upload failed' ),
									namespace: 'upload'
								} );
							}

							clean();

							// Permanently remove image from insertion batch.
							model.enqueueChange( 'transparent', writer => {
								writer.remove( imageElement );
							} );
						} );

					function clean() {
						model.enqueueChange( 'transparent', writer => {
							writer.removeAttribute( 'uploadId', imageElement );
							writer.removeAttribute( 'uploadStatus', imageElement );
						} );

						fileRepository.destroyLoader( loader );
					}
				}
			console.clear();
			console.log(window.editor.ui.componentFactory._components);
			window.editor.ui.componentFactory._components.get('gallery').callback().on('change:galleryIsOn', (p1, p2, p3) => {
				console.log( 'gallery');
				console.log( p1);
				console.log( p2);
				console.log( p3);
			});
			window.editor.ui.componentFactory._components.get('imagecrop').callback().on('change:cropIsOn', (p1, p2, p3) => {
				console.log( 'crop');
				console.log( p1);
				console.log( p2);
				console.log( p3);
			});
			editor.editing.view.document.on( 'enter', () => console.log( 'yes we can! enter' ));
			editor.model.schema.extend( 'image', {
				allowAttributes: 'data-uri'
			} );
			editor.conversion.for( 'upcast' ).attributeToAttribute( {
				view: 'data-uri',
				model: 'data-uri'
			} );
			editor.conversion.for( 'downcast' ).add( dispatcher => {
				dispatcher.on( 'attribute:data-uri:image', ( evt, data, conversionApi ) => {
					if ( !conversionApi.consumable.consume( data.item, evt.name ) ) {
						return;
					}

					const viewWriter = conversionApi.writer;
					const figure = conversionApi.mapper.toViewElement( data.item );
					const img = figure.getChild( 0 );

					if ( data.attributeNewValue !== null ) {
						viewWriter.setAttribute( 'data-uri', data.attributeNewValue, img );
					} else {
						viewWriter.removeAttribute( 'data-uri', img );
					}
				} );
			} );
			editor.model.schema.extend( 'image', {
				allowAttributes: 'data-src'
			} );
			editor.conversion.for( 'upcast' ).attributeToAttribute( {
				view: 'data-src',
				model: 'data-src'
			} );
			editor.conversion.for( 'downcast' ).add( dispatcher => {
				dispatcher.on( 'attribute:data-src:image', ( evt, data, conversionApi ) => {
					if ( !conversionApi.consumable.consume( data.item, evt.name ) ) {
						return;
					}

					const viewWriter = conversionApi.writer;
					const figure = conversionApi.mapper.toViewElement( data.item );
					const img = figure.getChild( 0 );

					if ( data.attributeNewValue !== null ) {
						viewWriter.setAttribute( 'data-src', data.attributeNewValue, img );
					} else {
						viewWriter.removeAttribute( 'data-src', img );
					}
				} );
			} );
			editor.model.enqueueChange('transparent', (writer, elem) => {
				console.log(elem);
			});
		} )
		.catch( error => {
			console.error( 'There was a problem initializing the editor.', error );
		} );
</script>

</body>
</html>
